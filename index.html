<!DOCTYPE html>

<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>WanderingViewer</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<style>
			@import url('https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap');

			body {
				margin: 0;
				padding: 0;
				font-family: 'Poppins', sans-serif;
			}

			#title {
				position: absolute;
				top: 2rem;
				width: 100%;
				text-align: center;
				color: white;
			}
			#title h1 {
				font-weight: 900;
				font-size: 3rem;
				margin: 0;
			}
			#title h2 {
				font-weight: 500;
				font-size: 1rem;
				margin: 0;
			}

			#instructions {
				position: absolute;
				bottom: 2rem;
				width: 100%;
				text-align: center;
				color: white;
			}
			#instructions p {
				font-weight: 300;
				font-size: 1rem;
				margin: 0;
			}
		</style>
	</head>
	
	<body>
		<div id="title">
			<h1>Wandering Mind</h1>
			<h2>Exploring Procedural Audio Journeys</h2>
		</div>

		<div id="instructions">
			<p><b>Click</b> and <b>Move</b> the mouse to <b>Orbit</b>. <b>Scroll</b> to <b>Zoom</b> in and out.</p>
		</div>

		<script type="module">
			import * as THREE from 'https://cdn.skypack.dev/three';
			import { OrbitControls } from 'https://cdn.skypack.dev/three/examples/jsm/controls/OrbitControls.js';
			import { Water } from 'https://cdn.skypack.dev/three/examples/jsm/objects/Water.js';
			import { EffectComposer } from 'https://cdn.skypack.dev/three/examples/jsm/postprocessing/EffectComposer.js';
			import { RenderPass } from 'https://cdn.skypack.dev/three/examples/jsm/postprocessing/RenderPass.js';
			import { UnrealBloomPass } from 'https://cdn.skypack.dev/three/examples/jsm/postprocessing/UnrealBloomPass.js';

			const loadImage = src => new Promise(resolve => {
				const img = new Image();
				img.onload = () => resolve(img);
				img.src = src;
			});

			const getImageData = async src => {
				const img = await loadImage(src);
				const cvs = document.createElement('canvas');
				const ctx = cvs.getContext('2d');
								
				cvs.width = img.width;
				cvs.height = img.height;
									
				ctx.drawImage(img, 0, 0);
				return ctx.getImageData(0, 0, img.width, img.height);
			};

			const getPixel = (data, x, y) => {
				const pos = (x + data.width * y) * 4;
				const val = data.data[pos] / 255.0;
				
				return val;
			};

			class Terrain {
				constructor(size, divisions, heightmap, data, scale, color) {
					this.size = size;
					this.divisions = divisions;
					this.heightmap = heightmap;
					this.data = data;
					this.scale = scale;
					this.color = color;

					this.geometry = new THREE.PlaneGeometry(this.size, this.size, this.divisions - 1, this.divisions - 1);
					this.material = new THREE.MeshStandardMaterial({
						color            : color,
						map              : heightmap,
						displacementMap  : heightmap,
						displacementScale: scale,
						roughness        : 0.95,
					});

					this.mesh = new THREE.Mesh(this.geometry, this.material);
					this.mesh.castShadow = true;
					this.mesh.recieveShadow = true;

					getImageData('images/heightmap.png').then(data => terrain.data = data);
				}

				height(x, z) {
					if (this.data === undefined)
						return 0;

					return getPixel(
						this.data,
						Math.floor((x + 0.5 * this.size) / this.size * this.data.width),
						Math.floor((z + 0.5 * this.size) / this.size * this.data.height),
					) * this.scale;
				}
			};

			class WaterPlane {
				constructor(normals, size, texture, color, sunColor, sunDirection, scale) {
					this.normals = normals;
					this.size = size;
					this.texture = texture;
					this.color = color;
					this.sunColor = sunColor;
					this.sunDirection = sunDirection;
					this.scale = scale;

					this.geometry = new THREE.PlaneGeometry(this.size, this.size);
					this.mesh = new Water(this.geometry, {
						textureWidth   : this.texture,
						textureHeight  : this.texture,
						waterNormals   : this.normals,
						sunDirection   : this.sunDirection,
						sunColor       : this.sunColor,
						waterColor     : this.color,
						distortionScale: this.scale,
						fog            : true,
					});
					this.mesh.castShadow = true;
					this.mesh.recieveShadow = true;
				}

				update(dt) { this.mesh.material.uniforms['time'].value += dt; }
			};

			class Particle {
				constructor(size, scale, color, intensity) {
					this.size = size;
					this.scale = scale;
					this.color = color;
					this.intensity = intensity;

					this.geometry = new THREE.BoxGeometry(this.size, this.size, this.size);
					this.material = new THREE.MeshStandardMaterial({
						color: this.color,
						emissive: this.color,
						emissiveIntensity: this.intensity,
						transparent: true,
						opacity: 1.0,
					});
					this.mesh = new THREE.Mesh(this.geometry, this.material);
					this.mesh.castShadow = true;
					this.mesh.scale.z = this.scale;
					
					this.x = 0.0;
					this.y = 0.5 * this.size * this.scale;
					this.z = 0.0;
				}
				
				position(x, y, z) {
					this.x = x;
					this.y = 0.5 * this.size * this.mesh.scale.z + y;
					this.z = z;
					
					this.mesh.material.opacity = 1.0;
					this.mesh.position.set(this.x, this.y, this.z);
					this.mesh.scale.z = this.scale;
				}

				update(dt) {
					this.mesh.material.visilbe = this.mesh.scale.z != 0;
					this.mesh.material.opacity = Math.max(0, this.mesh.material.opacity - dt);
					this.mesh.scale.z = Math.max(0, this.mesh.scale.z - 20.0 * dt);
				}
			};

			class Player {
				constructor(x, y, size, scale, color, intensity, amount) {
					this.x = x;
					this.y = y;
					this.size = size;
					this.scale = scale;
					this.color = color;
					this.intensity = intensity;
					this.amount = amount;
					
					this.idx = 0;
					this.particles = [];
					for (let i = 0; i < this.amount; i++)
						this.particles.push(
							new Particle(this.size, this.scale, this.color, this.intensity)
						);
				}

				update(dt, x, z) {
					const rx = 2.0 * Math.random() - 1.0;
					const rz = 2.0 * Math.random() - 1.0;
					const y  = terrain.height(x + rx, z + rz);

					this.particles.forEach(p => p.update(dt));
					this.particles[this.idx].position(x + rx, y, z + rz);

					this.idx = (this.idx + 1) % this.amount;
				}
			}

			const renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			document.body.appendChild(renderer.domElement);

			const loader = new THREE.TextureLoader();

			const scene      = new THREE.Scene();
			scene.background = new THREE.Color(0x000000);
			scene.fog        = new THREE.FogExp2(0x000000, 0.00025);
			
			const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 10, 1000);
			camera.position.set(30, 30, 100);

			const light = new THREE.DirectionalLight(0xbdeff0, 2.0);
			light.castShadow = true;
			light.shadow.mapSize.width = 512;
			light.shadow.mapSize.height = 512;
			light.position.set(10, 10, 10); 
			light.target.position.set(0, 0, 0); 
			scene.add(light);
			scene.add(light.target);
						
			const HEIGHTMAP = loader.load('images/heightmap.png');
			const terrain = new Terrain(512, 1024, HEIGHTMAP, undefined, 25.0, 0xbdeff0);
			terrain.mesh.rotation.x = -0.5 * Math.PI;
			scene.add(terrain.mesh);

			const WATERNORMALS = loader.load('images/waternormals.png');
			WATERNORMALS.wrapS = WATERNORMALS.wrapT = THREE.RepeatWrapping;
			
			const sunDirection = light.target.position.sub(light.position).normalize();
			const water = new WaterPlane(WATERNORMALS, 1024, 512, 0x000000, 0xbdeff0, sunDirection, 3.7);
			water.mesh.position.y = 0.05;
			water.mesh.rotation.x = -0.5 * Math.PI;
			scene.add(water.mesh);

			const players = [];
			players.push(new Player(0.0, 0.0, 0.5, 20.0, 0xff2100, 10.0, 64));
			players.push(new Player(0.0, 0.0, 0.5, 20.0, 0x0021ff, 10.0, 64));
			players.push(new Player(0.0, 0.0, 0.5, 20.0, 0x21ff00, 10.0, 64));
			players.forEach(player => player.particles.forEach(p => scene.add(p.mesh)));

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.minPolarAngle = 0.005;
			controls.maxPolarAngle = Math.PI * 0.495;
			controls.target.set(0, 10, 0);
			controls.minDistance = 40.0;
			controls.maxDistance = 400.0;
			controls.update();

			const render_size = new THREE.Vector2(window.innerWidth, window.innerHeight);
			const render_pass = new RenderPass(scene, camera);
			const bloom_pass = new UnrealBloomPass(render_size, 0.6, 0.4, 0.8);
			const composer = new EffectComposer(renderer);
			composer.addPass(render_pass);
			composer.addPass(bloom_pass);
			
			const render = () => {
				const time = performance.now() * 0.001;
				water.update(1.0 / 60.0);

				players.forEach(player => player.particles[player.idx].mesh.rotation.x = -0.5 * Math.PI);
				players[0].update(1.0 / 60.0, 30 * Math.sin(time) + 10, 30 * Math.cos(time) + 10, terrain);
				players[1].update(1.0 / 60.0, 30 * Math.cos(time) - 60, 30 * Math.cos(time) - 10, terrain);
				players[2].update(1.0 / 60.0, 30 * Math.cos(time) - 90, 30 * Math.sin(time) + 50, terrain);
			
				composer.render();
				requestAnimationFrame(render);
			};

			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
				bloom_pass.setSize(window.innerWidth, window.innerHeight);
			}, false);

			render();
		</script>
	</body>
</html>
